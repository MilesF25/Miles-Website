<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Miles Franck | Hub</title>
    <link rel="stylesheet" href="../../style.css">
</head>

<body>


    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>


    <nav>
        <div class="nav-container">
            <a href="#" class="logo">Miles</a>
            <ul class="nav-links">
                <li><a href="../../index.html">Home</a></li>
                <li><a href="https://github.com/MilesF25" target="_blank">Github</a></li>
                <li><a href="../contact.html">Contact</a></li>
                <li class="dropdown">
                    <span class="dropdown-toggle">Navigation</span>
                    <div class="dropdown-menu">
                        <a href="../experience_home_page/Personal_Projects.html">Projects</a>
                        <a href="../assets/Miles.Franck Resume.pdf" download target="_blank">Resume</a>
                    </div>
                </li>
            </ul>
        </div>
    </nav>
    <!-- Blog Post Container -->
    <article class="blog-post-container">
        <!-- Post Header -->
        <header class="post-header">
            <a href="rust-blog.html" class="back-link">← Back to Rust Blog</a>
            <h1 class="post-title">Adjusting to Rust</h1>
            <div class="post-info">
                <span>Dec 20, 2024</span>
                <span>•</span>
                <span>10 min read</span>
            </div>
        </header>

        <!-- Post Content -->
        <div class="post-content">
            <p>This took me a lot longer to figure out. I should probably just change the title to "My Python Brain Is
                Too Smooth To Handle Rust". My lord, I was trying to figure out how to do something as simple as change
                an
                String to an int so complicated. And the biggest issue is that its not even rusts fault! I am not a
                close minded person by any means but I was really stuck in my old python ways here.</p>

            <p>To start, I picked up back where I left off in the Rust book. Slices, its simple and similar to python
                slices. The only thing that tripped me up was this example they used to show why so you can't change an
                immutable reference.</p>

            <pre><code>fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // error!

    println!("the first word is: {word}");
}</code></pre>

            <p>For some reason i was just stuck on trying to figure out why they did this. It was an obvious bug, it
                took me some time before I read the paragraph bellow to understand it was on purpose. Aside from the
                small part slices were fine for me.</p>

            <p>The next part were structs. Structs in Rust is similar to classes in python. So again, that was easy for
                me to understand. The hard part came when i wanted to put the things I learned into practice. This was
                the journey I had to go through to break my old habit of thinking.</p>

            <p>So I thought that making a small program that lets you make a dnd character would be fun. Its simple,
                have the user give some attributes and then make a struct based off of that. Well it was, the hard part
                was getting the info.</p>

            <pre><code>struct Character {
    alive: bool,
    name: String,
    age: i32,
    species: String,
    // cant have negative kills
    kills: u32,
}</code></pre>

            <p>Here is the simple struct i used for the character. Simple and easy to implement. My next step was
                getting the info from the user.</p>

            <pre><code>fn intro() -> (String, i32, String) {
    println!("Welcom to the DND character builder!");
    println!("What is your name?");

    let mut name = String::new();
    io::stdin()
        .read_line(&mut name)
        .expect("Failed to read line");

    //this is to remove any whitespace from the string
    let name = cleanse(name); // Reassign the cleaned result back to 'name'
    //let clean_name = cleanse(name);

    // We declare that `age` will be an i32. It's empty for now.
    let age: i32 = loop {
        println!("Please enter your age:");

        // 1. `age_input` is created as a temporary String (e.g., "25\n").
        let mut age_input = String::new();
        io::stdin()
            .read_line(&mut age_input)
            .expect("Failed to read line");

        // 2. We call `.parse()` on the String. It creates a NEW temporary value: `Ok(25)`.
        match age_input.trim().parse::<i32>() {
            // 3. The `match` checks this new value. It fits the `Ok` pattern!
            Ok(num) => {
                // 4. The pattern `Ok(num)` UNWRAPS the value. The i32 value `25` is
                //    extracted and put into a BRAND NEW variable called `num`.
                //    At this exact moment, `num` IS the i32 you wanted.

                // 5. This is the magic. `break num;` does two things:
                //    a. It breaks the loop.
                //    b. It returns the value of `num` (the i32) from the loop.
                break num;
            }
            Err(_) => {
                // The parse failed. We print an error and the loop repeats.
                println!("You did not enter a valid number! Please try again.");
                continue;
            }
        }
    }; // 6. The `i32` value that came out of the loop is now assigned to our `age` variable.

    let mut species = String::new();
    println!("What is your species?");
    io::stdin()
        .read_line(&mut species)
        .expect("Failed to read line");

    //clean species
    // let clean_spe = cleanse(species);
    let species = cleanse(species); // Reassign the cleaned result back to 'species'
    let struct_values = (name, age, species);
    (struct_values)</code></pre>

            <p>Good lord, this was hell. Everything was fine until I had to get the age from the user. My Python brain
                is so used to just doing something simple like int_number = int("123"). I wish I could do this in Rust,
                it would make it simple but because of Rust's rules, I needed to take the long way around. Part of it is
                my fault, if I had just kept it simple I could have just used a function that returns a bool and called
                it a day, but I wanted to get the number back. I had no idea what a journey that would be.</p>

            <p>My first thought was, "Okay, I have the user's input as a String, I just need to change it." I found the
                .parse() method, which seemed right. So I tried something like:</p>

            <p><code>let age = age_input.parse::&lt;i32&gt;();</code></p>

            <p>And bam, my first wall. The compiler started yelling at me. It turns out .parse() doesn't just give you
                the number. It gives you this thing called a Result. It's a container that's either Ok(the_number) if it
                worked, or Err(some_error) if the user typed "cat" instead of "25".</p>

            <p>So my Python brain thought, "Okay, it's like a try...except block, I get it." My first instinct was to
                just crash the program if it failed. I found .expect(), which seemed perfect for that.</p>

            <p><code>let age: i32 = age_input.parse().expect("This should have been a number!");</code></p>

            <p>This worked. If the user makes a typo, my whole character creator just dies. I don't want that so I had
                to figure out how to get the actual value if the parse returned ok. My first attempt was to use
                unwrap(). Unwrap() will give you the value inside the result but its not recommended for production code
                because it does not handle crashes gracefully. If the user were to enter a string my code will crash at
                the unwrap function with no chance of recovery, so that was out of the question. At this point I've been
                stuck at this point for a while, for some reason my brain could not understand how to solve this
                problem. At the end I'll go into a more in depth explanation on what was holding me back but for now
                I'll explain how I solved the problem.</p>

            <p>Looking back it is pretty simple but at the time it was didn't make sense to me. How could I get the
                value from a successful operation in a safe way? To do that I used Ok(). Here is what I did</p>

            <pre><code>match age_input.trim().parse::(i32);() {
                //Had do use () cause html encoding
    Ok(number) => {
        break number
    }
    Err(e) => {
        false       
    }
}</code></pre>

            <p>Ok() allows me to get the value of a successful result. There for letting me finally have a safe way to
                get the value. Now that the issue is solved I could move on to the next part of my program. Putting the
                entire thing together.</p>

            <pre><code>fn intro() -> (String, i32, String) {
    println!("Welcom to the DND character builder!");
    println!("What is your name?");

    let mut name = String::new();
    io::stdin()
        .read_line(&mut name)
        .expect("Failed to read line");

    //this is to remove any whitespace from the string
    let name = cleanse(name);

    // We declare that `age` will be an i32. It's empty for now.
    let age: i32 = loop {
        println!("Please enter your age:");

        //  `age_input` is created as a temporary String .
        let mut age_input = String::new();
        io::stdin()
            .read_line(&mut age_input)
            .expect("Failed to read line");
        // 2 call `.parse()` on the String. It creates a NEW temporary value: `Ok(25)`.
        match age_input.trim().parse::&lt;i32&gt;() {
            // 3. The `match` checks this new value. It fits the `Ok` pattern
            Ok(num) => {
                // 4. The pattern `Ok(num)` UNWRAPS the value. The i32 value `25` is
                //    extracted and put into a BRAND NEW variable called `num`.
                //    At this exact moment, `num` IS the i32
                // 5. `break num;` does two things:
                //    a. It breaks the loop.
                //    b. It returns the value of `num` (the i32) from the loop.
                break num;
            }
            Err(_) => {
                // The parse failed.
                println!("You did not enter a valid number! Please try again.");
                continue;
            }
        }
    }; // 6. The i32 value that came out of the loop is now assigned to the age variable.

    let mut species = String::new();
    println!("What is your species?");
    io::stdin()
        .read_line(&mut species)
        .expect("Failed to read line");

    let species = cleanse(species); // Reassign the cleaned result back to species
    let struct_values = (name, age, species);
    (struct_values)
}</code></pre>

            <p>Here is the entire function for getting info from the user. I ran into a issue with the looping part at
                age. I wanted to have it loop until a correct answer was given. I had to ask ai cause I had no idea it
                was possible to do it like this. The final hurdle i faced was at the very end.</p>

            <pre><code>let (name, age, species) = intro();
let mut player1 = character {
    alive: true,
    name: name.clone(),
    age: age,
    species: species.clone(),
    kills: 0,
};
println!(
    "Your name is {}, you're {} years old, you are a {}. ",
    name, age, species
);

print!("Now roll a dice to determine what happens");
dice_roll();</code></pre>

            <p>The issue I had here was one with ownership. Look at how name and species have the copy function. That
                needed to be added because of how ownership works in Rust. When the name variable is assigned to the
                name value in the struct, it removes the value from the original variable leaving it empty. With out the
                clone function I would get an error at the println! statement because I'd essentially be trying to print
                an empty value. I did not have to do it for the i32 because by default, Rust will make a copy of ints.
            </p>

            <p>My struggle with converting a string to an integer was, at its core, a trial-by-fire against Rust's
                fundamental concepts. My Python brain collided directly with Rust's strict rules, and what I thought
                would be a simple type change turned into a deep dive into Result, ownership, and scope. I initially
                struggled because I was looking for a simple action, a function to change my string into a number.
                Instead, Rust handed me a Result, a mandatory container that forced me to acknowledge and handle both
                success (Ok) and failure (Err) upfront, rather than just waiting for a crash. This tied directly into
                ownership; I had to learn that .parse() doesn't modify the old variable but creates a completely new
                value that must be captured.</p>
        </div>

        <!-- Post Footer -->
        <footer class="post-footer">
            <a href="rust-blog.html" class="back-link">← Back to Rust Blog</a>
        </footer>
    </article>
</body>

</html>